"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ARGUMENT_COMPOSITION_STRATEGIES = void 0;
const definitions_1 = require("./definitions");
const types_1 = require("./types");
const values_1 = require("./values");
function supportFixedTypes(types) {
    return (schema, type) => {
        const supported = types(schema);
        if (!supported.some((t) => (0, types_1.sameType)(t, type))) {
            return { valid: false, supportedMsg: `type(s) ${supported.join(', ')}` };
        }
        return { valid: true };
    };
}
function supportAnyNonNullArray() {
    return (_, type) => {
        if (!(0, definitions_1.isNonNullType)(type) || !(0, definitions_1.isListType)(type.ofType)) {
            return { valid: false, supportedMsg: 'non nullable list types of any type' };
        }
        return { valid: true };
    };
}
exports.ARGUMENT_COMPOSITION_STRATEGIES = {
    MAX: {
        name: 'MAX',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => Math.max(...values),
    },
    MIN: {
        name: 'MIN',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => Math.min(...values),
    },
    SUM: {
        name: 'SUM',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => values.reduce((acc, val) => acc + val, 0),
    },
    INTERSECTION: {
        name: 'INTERSECTION',
        isTypeSupported: supportAnyNonNullArray(),
        mergeValues: (values) => values.reduce((acc, val) => acc.filter((v1) => val.some((v2) => (0, values_1.valueEquals)(v1, v2))), values[0]),
    },
    UNION: {
        name: 'UNION',
        isTypeSupported: supportAnyNonNullArray(),
        mergeValues: (values) => values.reduce((acc, val) => {
            const newValues = val.filter((v1) => !acc.some((v2) => (0, values_1.valueEquals)(v1, v2)));
            return acc.concat(newValues);
        }, []),
    },
};
//# sourceMappingURL=argumentCompositionStrategies.js.map