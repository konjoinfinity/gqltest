{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/link/persisted-queries/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from '../../utilities/globals';\n\nimport { print } from 'graphql';\nimport {\n  DocumentNode,\n  ExecutionResult,\n  GraphQLError,\n} from 'graphql';\n\nimport { ApolloLink, Operation } from '../core';\nimport {\n  Observable,\n  Observer,\n  ObservableSubscription,\n  compact,\n  isNonEmptyArray,\n} from '../../utilities';\nimport { NetworkError } from '../../errors';\nimport { ServerError } from '../utils';\n\nexport const VERSION = 1;\n\nexport interface ErrorResponse {\n  graphQLErrors?: readonly GraphQLError[];\n  networkError?: NetworkError;\n  response?: ExecutionResult;\n  operation: Operation;\n  meta: ErrorMeta;\n}\n\ntype ErrorMeta = {\n  persistedQueryNotSupported: boolean;\n  persistedQueryNotFound: boolean;\n}\n\ntype SHA256Function = (...args: any[]) => string | PromiseLike<string>;\ntype GenerateHashFunction = (document: DocumentNode) => string | PromiseLike<string>;\n\ninterface BaseOptions {\n  disable?: (error: ErrorResponse) => boolean;\n  retry?: (error: ErrorResponse) => boolean;\n  useGETForHashedQueries?: boolean;\n};\n\nexport namespace PersistedQueryLink {\n  interface SHA256Options extends BaseOptions {\n    sha256: SHA256Function;\n    generateHash?: never;\n  };\n\n  interface GenerateHashOptions extends BaseOptions {\n    sha256?: never;\n    generateHash: GenerateHashFunction;\n  };\n\n  export type Options = SHA256Options | GenerateHashOptions;\n}\n\nfunction processErrors(\n  graphQLErrors: GraphQLError[] | readonly GraphQLError[] | undefined\n): ErrorMeta {\n  const byMessage = Object.create(null),\n        byCode = Object.create(null);\n\n  if (isNonEmptyArray(graphQLErrors)) {\n    graphQLErrors.forEach((error) => {\n      byMessage[error.message] = error;\n      if (typeof error.extensions?.code == \"string\")\n        byCode[error.extensions.code] = error;\n    });\n  }\n  return {\n    persistedQueryNotSupported: !!(byMessage.PersistedQueryNotSupported || byCode.PERSISTED_QUERY_NOT_SUPPORTED),\n    persistedQueryNotFound: !!(byMessage.PersistedQueryNotFound || byCode.PERSISTED_QUERY_NOT_FOUND),\n  };\n}\n\nconst defaultOptions: Required<BaseOptions> = {\n  disable: ({ meta }) => meta.persistedQueryNotSupported,\n  retry: ({ meta }) => meta.persistedQueryNotSupported || meta.persistedQueryNotFound,\n  useGETForHashedQueries: false,\n};\n\nfunction operationDefinesMutation(operation: Operation) {\n  return operation.query.definitions.some(\n    d => d.kind === 'OperationDefinition' && d.operation === 'mutation');\n}\n\nexport const createPersistedQueryLink = (\n  options: PersistedQueryLink.Options,\n) => {\n  const hashesByQuery = new WeakMap<\n    DocumentNode,\n    Promise<string>\n  >();\n  // Ensure a SHA-256 hash function is provided, if a custom hash\n  // generation function is not provided. We don't supply a SHA-256 hash\n  // function by default, to avoid forcing one as a dependency. Developers\n  // should pick the most appropriate SHA-256 function (sync or async) for\n  // their needs/environment, or provide a fully custom hash generation\n  // function (via the `generateHash` option) if they want to handle\n  // hashing with something other than SHA-256.\n  invariant(\n    options && (\n      typeof options.sha256 === 'function' ||\n      typeof options.generateHash === 'function'\n    ),\n    'Missing/invalid \"sha256\" or \"generateHash\" function. Please ' +\n      'configure one using the \"createPersistedQueryLink(options)\" options ' +\n      'parameter.'\n  );\n\n  const {\n    sha256,\n    // If both a `sha256` and `generateHash` option are provided, the\n    // `sha256` option will be ignored. Developers can configure and\n    // use any hashing approach they want in a custom `generateHash`\n    // function; they aren't limited to SHA-256.\n    generateHash = (query: DocumentNode) => Promise.resolve<string>(sha256!(print(query))),\n    disable,\n    retry,\n    useGETForHashedQueries,\n  } = compact(defaultOptions, options);\n\n  let supportsPersistedQueries = true;\n\n  const getHashPromise = (query: DocumentNode) =>\n    new Promise<string>(resolve => resolve(generateHash(query)));\n\n  function getQueryHash(query: DocumentNode): Promise<string> {\n    if (!query || typeof query !== 'object') {\n      // If the query is not an object, we won't be able to store its hash as\n      // a property of query[hashesKey], so we let generateHash(query) decide\n      // what to do with the bogus query.\n      return getHashPromise(query);\n    }\n    let hash = hashesByQuery.get(query)!;\n    if (!hash) hashesByQuery.set(query, hash = getHashPromise(query));\n    return hash;\n  }\n\n  return new ApolloLink((operation, forward) => {\n    invariant(\n      forward,\n      'PersistedQueryLink cannot be the last link in the chain.'\n    );\n\n    const { query } = operation;\n\n    return new Observable((observer: Observer<ExecutionResult>) => {\n      let subscription: ObservableSubscription;\n      let retried = false;\n      let originalFetchOptions: any;\n      let setFetchOptions = false;\n      const maybeRetry = (\n        {\n          response,\n          networkError,\n        }: { response?: ExecutionResult; networkError?: ServerError },\n        cb: () => void,\n      ) => {\n        if (!retried && ((response && response.errors) || networkError)) {\n          retried = true;\n\n          const graphQLErrors: GraphQLError[] = [];\n\n          const responseErrors = response && response.errors;\n          if (isNonEmptyArray(responseErrors)) {\n            graphQLErrors.push(...responseErrors);\n          }\n\n          // Network errors can return GraphQL errors on for example a 403\n          let networkErrors;\n          if (typeof networkError?.result !== 'string') {\n            networkErrors =\n              networkError &&\n              networkError.result &&\n              networkError.result.errors as GraphQLError[];\n          }\n          if (isNonEmptyArray(networkErrors)) {\n            graphQLErrors.push(...networkErrors);\n          }\n\n          const disablePayload: ErrorResponse = {\n            response,\n            networkError,\n            operation,\n            graphQLErrors: isNonEmptyArray(graphQLErrors) ? graphQLErrors : void 0,\n            meta: processErrors(graphQLErrors)\n          };\n\n          // if the server doesn't support persisted queries, don't try anymore\n          supportsPersistedQueries = !disable(disablePayload);\n\n          // if its not found, we can try it again, otherwise just report the error\n          if (retry(disablePayload)) {\n            // need to recall the link chain\n            if (subscription) subscription.unsubscribe();\n            // actually send the query this time\n            operation.setContext({\n              http: {\n                includeQuery: true,\n                includeExtensions: supportsPersistedQueries,\n              },\n              fetchOptions: {\n                // Since we're including the full query, which may be\n                // large, we should send it in the body of a POST request.\n                // See issue #7456.\n                method: 'POST',\n              },\n            });\n            if (setFetchOptions) {\n              operation.setContext({ fetchOptions: originalFetchOptions });\n            }\n            subscription = forward(operation).subscribe(handler);\n\n            return;\n          }\n        }\n        cb();\n      };\n      const handler = {\n        next: (response: ExecutionResult) => {\n          maybeRetry({ response }, () => observer.next!(response));\n        },\n        error: (networkError: ServerError) => {\n          maybeRetry({ networkError }, () => observer.error!(networkError));\n        },\n        complete: observer.complete!.bind(observer),\n      };\n\n      // don't send the query the first time\n      operation.setContext({\n        http: {\n          includeQuery: !supportsPersistedQueries,\n          includeExtensions: supportsPersistedQueries,\n        },\n      });\n\n      // If requested, set method to GET if there are no mutations. Remember the\n      // original fetchOptions so we can restore them if we fall back to a\n      // non-hashed request.\n      if (\n        useGETForHashedQueries &&\n        supportsPersistedQueries &&\n        !operationDefinesMutation(operation)\n      ) {\n        operation.setContext(\n          ({ fetchOptions = {} }: { fetchOptions: Record<string, any> }) => {\n            originalFetchOptions = fetchOptions;\n            return {\n              fetchOptions: {\n                ...fetchOptions,\n                method: 'GET',\n              },\n            };\n          },\n        );\n        setFetchOptions = true;\n      }\n\n      if (supportsPersistedQueries) {\n        getQueryHash(query).then((sha256Hash) => {\n          operation.extensions.persistedQuery = {\n            version: VERSION,\n            sha256Hash,\n          };\n          subscription = forward(operation).subscribe(handler);\n        }).catch(observer.error!.bind(observer));;\n      } else {\n        subscription = forward(operation).subscribe(handler);\n      }\n\n      return () => {\n        if (subscription) subscription.unsubscribe();\n      };\n    });\n  });\n};\n"]}