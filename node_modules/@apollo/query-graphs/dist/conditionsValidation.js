"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleValidationConditionResolver = void 0;
const graphPath_1 = require("./graphPath");
const conditionsCaching_1 = require("./conditionsCaching");
class ConditionValidationState {
    constructor(selection, subgraphOptions) {
        this.selection = selection;
        this.subgraphOptions = subgraphOptions;
    }
    advance(supergraph) {
        let newOptions = [];
        for (const paths of this.subgraphOptions) {
            const pathsOptions = (0, graphPath_1.advanceSimultaneousPathsWithOperation)(supergraph, paths, this.selection.element);
            if (!pathsOptions) {
                continue;
            }
            newOptions = newOptions.concat(pathsOptions);
        }
        if (newOptions.length === 0) {
            return null;
        }
        return this.selection.selectionSet ? this.selection.selectionSet.selections().map(s => new ConditionValidationState(s, newOptions)) : [];
    }
    toString() {
        return `${this.selection} <=> ${(0, graphPath_1.advanceOptionsToString)(this.subgraphOptions)}`;
    }
}
function simpleValidationConditionResolver({ supergraph, queryGraph, withCaching, }) {
    const resolver = (edge, context, excludedDestinations, excludedConditions) => {
        const conditions = edge.conditions;
        excludedConditions = (0, graphPath_1.addConditionExclusion)(excludedConditions, conditions);
        const initialPath = graphPath_1.GraphPath.create(queryGraph, edge.head);
        const initialOptions = [
            new graphPath_1.SimultaneousPathsWithLazyIndirectPaths([initialPath], context, simpleValidationConditionResolver({ supergraph, queryGraph, withCaching }), excludedDestinations, excludedConditions)
        ];
        const stack = [];
        for (const selection of conditions.selections()) {
            stack.push(new ConditionValidationState(selection, initialOptions));
        }
        while (stack.length > 0) {
            const state = stack.pop();
            const newStates = state.advance(supergraph);
            if (newStates === null) {
                return graphPath_1.unsatisfiedConditionsResolution;
            }
            newStates.forEach(s => stack.push(s));
        }
        return { satisfied: true, cost: 1 };
    };
    return withCaching ? (0, conditionsCaching_1.cachingConditionResolver)(queryGraph, resolver) : resolver;
}
exports.simpleValidationConditionResolver = simpleValidationConditionResolver;
//# sourceMappingURL=conditionsValidation.js.map